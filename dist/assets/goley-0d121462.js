import"./jquery-2beb4599.js";const a=i=>{let t=i;t.isMatrx&&(t=t.elements);let e=0;for(let n in t)t[n]!==0&&e++;return e},m=(i,t=0)=>{const e=[];for(let n=0;n<i;n++)e.push(t);return e},c=(i,t)=>{if(i.length!==t.length)throw new Error("Vectors must have the same length");const e=[];for(let n in i)e[n]=i[n]+t[n];return e},u=i=>i.map(t=>t%2),f=(i,t)=>{const e=[];for(let n=0;n<i;n++)e[n]=(n==t)+0;return e},R=(i,t)=>{let e=[],n=0;for(let o=0;o<i;o++)Math.random()*i<t?(e.push(1),n++):e.push(0);return{vec:e,noise:n}};function l(){}class p{constructor(t=0,e=0,n=null){if(this._onChangeListeners=[],this.width=e,this.height=t,n)this.elements=n;else{this.elements=[];for(let o=0;o<e*t;o++)this.elements.push(0)}}get isMatrx(){return!0}addRow(t){if(t.length!==this.width)throw new Error("In order to add a row to a Matrix, it must have the same length as Matrix width");return this.height++,this.elements=this.elements.concat(t),this._callOnChanged(l),this}addCol(t){if(t.length!==this.height)throw new Error("In order to add a column to a Matrix, it must have the same length as Matrix height");for(let e=0;e<this.height;e++)this.elements.splice(this.width*e,0,t[e]);return this._callOnChanged(l),this}clone(){return new this.constructor(this.width,this.height,this.elements)}get(t,e){return this.elements[t*this.width+e]}set(t,e,n){return this.elements[t*this.width+e]=n,this._callOnChanged(l),this}getRow(t){return this.elements.slice(this.width*t,this.width*(t+1))}getCol(t){const e=[];for(let n=0;n<this.height;n++)e.push(this.get(n,t));return e}getRows(){const t=[];for(let e=0;e<this.height;e++)t.push(this.getRow(e));return t}add(t){if(this.width!==t.width||this.height!==t.height)throw new Error("In order to add two matrices their width and height must be the same");const e=new this.constructor(this.height,this.width);for(let n in this.elements)e.elements[n]=this.elements[n]+t.elements[n];return e._callOnChanged(l),e}addTo(t,e,n){return this.set(t,e,this.get(t,e)+n),this._callOnChanged(l),this}transpose(){const t=new this.constructor(this.width,this.height);for(let e=0;e<this.height;e++)for(let n=0;n<this.width;n++)t.set(n,e,this.get(e,n));return t}mult(t){if(this.width!==t.height)throw new Error("In order to multiply matrices the number of columns in the first one must be equal to the number of rows in the second one!");const e=new this.constructor(this.height,t.width);for(let n=0;n<e.height;n++)for(let o=0;o<e.width;o++){e.set(n,o,0);for(let r=0;r<t.height;r++)e.addTo(n,o,this.get(n,r)*t.get(r,o))}return e}toString(t="<br>"){let e="";for(let n=0;n<this.height;n++){for(let o=0;o<this.width;o++)e+=this.get(n,o)+" ";e+=t}return e}printToTable(){const t=[];for(let e=0;e<this.height;e++)t.push(this.elements.slice(this.width*e,this.width*(e+1)));return console.table(t),this}forEach(t){for(let e=0;e<this.height;e++)for(let n=0;n<this.width;n++)t.bind(this)(this.get(e,n),e,n,this);return this._callOnChanged(l),this}_callOnChanged(t){if(t!==l)throw new Error("_callOnChanged function is a private function, it cannot be called from the outside of class Matrix");for(let e in this._onChangeListeners)this._onChangeListeners[e].bind(this)(this)}onChange(t){return this._onChangeListeners.push(t),this}static Identity(t){const e=new this.constructor(t,t);for(let n=0;n<t;n++)e.set(n,n,1);return e}}class g extends p{constructor(...t){super(...t),this.onChange(B)}get isBinaryMatrix(){return!0}}function B(i){for(let t in i.elements)i.elements[t]%=2}class s{constructor(){throw new Error("Golay code is not an instantiatable class, use static methods instead")}static encode(t){return t.isBinaryMatrix||(t=new g(1,12,t)),t.mult(s.G).getRow(0)}static decode(t){let e=null;t.isBinaryMatrix||(t=new g(1,24,t)),s.Log("Step 1");const n=t.mult(s.H.transpose()).getRow(0);s.Log("Calculated Syndrome",n.join(", ")),t=t.getRow(0);const o=a(n);if(s.Log("Step 2"),s.Log("Syndrome weight is",o),o<=3)return s.Log("Syndrome weight is less than or equal to 3, solution found!"),e=n.concat(m(12)),u(c(e,t));s.Log("Step 3");const r=s.B.getRows();for(let h in r){const d=u(c(n,r[h]));if(a(d)<=2)return s.Log(`B_${h} is a good match, the weight of S+B_${h} is ${a(d)} <= 2`),e=d.concat(f(12,h)),u(c(e,t))}s.Log("Step 4");const w=new g(1,n.length,n).mult(s.B).getRow(0);if(s.Log("Calculated second syndrome, it is ",w),s.Log("Step 5"),a(w)<=3)return s.Log(`Second syndrome weight is ${a(w)} <= 3`),e=m(12).concat(w),u(c(e,t));s.Log("Step 6");for(let h in r){const d=u(c(w,r[h]));if(a(d)<=2)return s.Log(`B_${h} is a good match, the weight of SS+B_${h} is ${a(d)} <= 2`),e=f(12,h).concat(d),u(c(e,t))}return s.Log("Step 7"),s.Log("Cant find solution, data is too corrupted"),[]}static Log(...t){for(let e in s.logHandlers)s.logHandlers[e](...t)}static addLogHandler(t){s.logHandlers.push(t)}}s.logHandlers=[];s.H=new g(0,24);s.H.addRow([1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,1]);s.H.addRow([0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,0,0,1,0,1,1]);s.H.addRow([0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,1]);s.H.addRow([0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1]);s.H.addRow([0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1]);s.H.addRow([0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1]);s.H.addRow([0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1]);s.H.addRow([0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,0,1]);s.H.addRow([0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,1,1,0,0,1]);s.H.addRow([0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,1,1,1,0,0,0,1]);s.H.addRow([0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,1,0,0,0,1,1]);s.H.addRow([0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0]);s.G=new g(0,24);s.G.addRow([1,1,0,1,1,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0]);s.G.addRow([1,0,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0]);s.G.addRow([0,1,1,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0]);s.G.addRow([1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0]);s.G.addRow([1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0]);s.G.addRow([1,0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0]);s.G.addRow([0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0]);s.G.addRow([0,0,1,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0]);s.G.addRow([0,1,0,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0]);s.G.addRow([1,0,1,1,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0]);s.G.addRow([0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0]);s.G.addRow([1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1]);s.B=new g(0,12);s.B.addRow([1,1,0,1,1,1,0,0,0,1,0,1]);s.B.addRow([1,0,1,1,1,0,0,0,1,0,1,1]);s.B.addRow([0,1,1,1,0,0,0,1,0,1,1,1]);s.B.addRow([1,1,1,0,0,0,1,0,1,1,0,1]);s.B.addRow([1,1,0,0,0,1,0,1,1,0,1,1]);s.B.addRow([1,0,0,0,1,0,1,1,0,1,1,1]);s.B.addRow([0,0,0,1,0,1,1,0,1,1,1,1]);s.B.addRow([0,0,1,0,1,1,0,1,1,1,0,1]);s.B.addRow([0,1,0,1,1,0,1,1,1,0,0,1]);s.B.addRow([1,0,1,1,0,1,1,1,0,0,0,1]);s.B.addRow([0,1,1,0,1,1,1,0,0,0,1,1]);s.B.addRow([1,1,1,1,1,1,1,1,1,1,0,0]);document.addEventListener("DOMContentLoaded",i=>{document.getElementById("random").addEventListener("click",()=>{const t=[];for(let e=0;e<12;e++)t.push(parseInt(Math.random()*2));document.getElementById("source").value=t.join("")}),document.getElementById("encode").addEventListener("click",()=>{const t=document.getElementById("source").value.split("").map(n=>parseInt(n));if(t.length!==12){alert("Код должен быть длиной в 12 бит!");return}const e=s.encode(t);document.getElementById("result").value=e.join("")}),document.getElementById("corrupt").addEventListener("click",()=>{const t=R(24,4),e=document.getElementById("result").value.split("").map(n=>parseInt(n));document.getElementById("corrupted").value=u(c(t.vec,e)).join(""),document.getElementById("corruptedBits").innerText=t.noise,t.noise>3?document.getElementById("message").innerText="Искажение слишком сильное. Корректное восстановление не гарантировано.":document.getElementById("message").innerText=""}),document.getElementById("decode").addEventListener("click",()=>{const t=document.getElementById("corrupted").value.split("").map(e=>parseInt(e));document.getElementById("restored").value=s.decode(t).join("")}),s.addLogHandler(logToDocument)});
